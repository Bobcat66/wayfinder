/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2025 Jesse Kane
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

// This file was automatically generated by JVal. Do not attempt to modify manually

#pragma once

#include "jv_capi.h"
#include <nlohmann/json.hpp>
#include <cstdint>
#include <optional>
#include <unordered_set>
#include <unordered_map>
#include <regex>
#include <limits>
#include <deque>

namespace jval {

    using JSON = nlohmann::json;

    constexpr size_t array_maxsize = std::numeric_limits<std::size_t>::max();

    enum class JVStatus : std::uint8_t {
        OK =                    0x00,
        MISSING_PROPERTY =      0x01,
        BAD_TYPE =              0x02,
        SCHEMA_VIOLATION =      0x03,
        PARSE_ERROR =           0x04,
        UNKNOWN =               0xff
    };

    inline constexpr std::string_view jvstatus_name(JVStatus status) {
        switch (status) {
            case JVStatus::MISSING_PROPERTY:    return "MISSING_PROPERTY";
            case JVStatus::BAD_TYPE:            return "BAD_TYPE";
            case JVStatus::SCHEMA_VIOLATION:    return "SCHEMA_VIOLATION";
            case JVStatus::PARSE_ERROR:         return "PARSE_ERROR";
            case JVStatus::UNKNOWN:             return "UNKNOWN";
            default:                            return "UNRECOGNIZED";
        };
    }

    class JVResult {
    public:
        JVResult(JVStatus status, std::deque<std::string> path)
        : status_(status), path_(std::move(path)) {}
        std::string what() const;
        JVStatus status() const noexcept { return status_; }
        JVResult prependToPath(std::string path_ele);
        jval_res_t* c_api();
        constexpr bool ok() const noexcept { return status_ == JVStatus::OK; }
        constexpr explicit operator bool() const noexcept { return ok(); }
    private:
        const JVStatus status_;
        std::deque<std::string> path_;
    };

    // An interface for objects that implement JSON validation
    // ALL JSONValidationFunctor objects should be STATIC objects with "eternal" lifetime
    // Additionally, calling the functors should be STRICTLY read-only
    class JSONValidationFunctor {
    public:
        virtual JVResult operator()(const JSON& jobject) const = 0;
    };

    class JSONNullValidator : public JSONValidationFunctor {
    public:
        JVResult operator()(const JSON& jobject) const override {
            return JVResult(JVStatus::OK,{});
        }
    };

    const JSONValidationFunctor* getNullValidator() {
        static JSONNullValidator validator;
        return static_cast<JSONValidationFunctor*>(&validator);
    }

    // Meant for validating primitive types (number, string, etc.)
    template <typename T>
    class JSONPrimitiveValidator : public JSONValidationFunctor {
    public:
        JVResult operator()(const JSON& jobject) const override {
            try {
                jobject.get<T>();
                return JVResult(JVStatus::OK,{});
            } catch (const JSON::type_error& e) {
                return JVResult(JVStatus::BAD_TYPE,{});
            } catch (const JSON::exception& e) {
                return JVResult(JVStatus::UNKNOWN,{});
            }
        }
    };


    template <typename T>
    const JSONValidationFunctor* getPrimitiveValidator() {
        static JSONPrimitiveValidator<T> validator;
        return static_cast<JSONValidationFunctor*>(&validator);
    }

    // Meant for validating JSON objects with explicitly defined and typed properties
    // (i.e. JSON objects that behave like structs)
    class JSONStructValidator : public JSONValidationFunctor {
    public:
        JSONStructValidator(
            std::unordered_map<std::string,const JSONValidationFunctor*> properties_,
            std::unordered_set<std::string> required_,
            std::unordered_map<std::string,std::unordered_set<std::string>> dependencies_
        ) 
        : properties(std::move(properties_))
        , required(std::move(required_)) 
        , dependencies(std::move(dependencies_)) {}
        JVResult operator()(const JSON& jobject) const override;
    private:
        const std::unordered_map<std::string,const JSONValidationFunctor*> properties;
        const std::unordered_set<std::string> required;
        const std::unordered_map<std::string,std::unordered_set<std::string>> dependencies;
    };

    // Meant for validating objects with an indeterminate number of properties that share a type
    // (i.e. JSON objects that behave like maps)
    class JSONMapValidator : public JSONValidationFunctor {
    public:
        JSONMapValidator(const JSONValidationFunctor* valueValidator_,const std::string& keyPattern = R"(^.*$)") : valueValidator(valueValidator_), keyMatcher(keyPattern) {}
        JVResult operator()(const JSON& jobject) const override;
    private:
        const std::regex keyMatcher;
        const JSONValidationFunctor* valueValidator;
    };

    class JSONEnumValidator : public JSONValidationFunctor {
    public:
        JSONEnumValidator(std::unordered_set<std::string> enumValues_) : enumValues(std::move(enumValues_)) {}
        JVResult operator()(const JSON& jobject) const override;
    private:
        const std::unordered_set<std::string> enumValues;
    };

    class JSONArrayValidator : public JSONValidationFunctor {
    public:
        JSONArrayValidator(const JSONValidationFunctor* valueValidator_,size_t minSize_ = 0,size_t maxSize_ = array_maxsize)
        : valueValidator(valueValidator_), minSize(minSize_), maxSize(maxSize_) {}
        JVResult operator()(const JSON& jobject) const override;
    private:
        const size_t minSize;
        const size_t maxSize;
        const JSONValidationFunctor* valueValidator;
    };

    class JSONUnionValidator : public JSONValidationFunctor {
    public:
        JSONUnionValidator(std::vector<JSONValidationFunctor*> validators_) : validators(std::move(validators_)) {}
        JVResult operator()(const JSON& jobject) const override;
    private:
        const std::vector<JSONValidationFunctor*> validators;
    };

    class JSONPatternValidator: public JSONValidationFunctor {
    public:
        JSONPatternValidator(const std::string& pattern = R"(^.*$)") : patternMatcher(pattern) {}
        JVResult operator()(const JSON& jobject) const override;
    private:
        const std::regex patternMatcher;
    };

}