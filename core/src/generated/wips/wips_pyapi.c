/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2025 Jesse Kane
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

// This file was automatically generated by WIPS. Do not attempt to modify manually

#ifdef WIPS_OPTION_BUILD_PYTHON

#ifdef __cplusplus
extern "C" {
#endif

#define PY_SSIZE_T_CLEAN
#include "wips_pyapi.h"

#define WIPS_INTERNAL
#include "wips_detail.h"

#ifndef __cplusplus
#define thread_local _Thread_local
#endif

void wips_blob_void_destructor(void *blob) {
    wips_blob_destroy((wips_blob_t *)blob);
}

// NOTE: This implementation is not thread-safe. Safe under the GIL
struct wips_handler {
    void *resource;
    size_t refcount;
    void (*destructor)(void *);
};


wips_PyHandler *wips_PyHandler_create(void *resource,void (*destructor)(void *)) {
    wips_PyHandler *handler = (wips_PyHandler *)malloc(sizeof(wips_PyHandler));
    if (!handler) return NULL;
    handler->resource = resource;
    handler->destructor = destructor;
    handler->refcount = 1;
    return handler;
}

wips_PyHandler *wips_PyHandler_incref(wips_PyHandler *handler) {
    if (!handler) return NULL;
    handler->refcount++;
    return handler;
}

wips_PyHandler *wips_PyHandler_decref(wips_PyHandler *handler) {
    if (!handler) return NULL;
    handler->refcount--;
    if (!(handler->refcount)) {
        if (!handler->destructor) {
            free(handler->resource);
        } else {
            handler->destructor(handler->resource);
        }
        free(handler);
        return NULL;
    }
    return handler;
}



// The pointer returned by this function is owned by the handler and should NOT be freed manually
void *wips_PyHandler_get(wips_PyHandler *handler) {
    if (!handler) return NULL;
    return handler->resource;
}



// blob methods
static void wips_blob_PyObject_dealloc(PyObject *self) {

    wips_blob_PyObject *obj = (wips_blob_PyObject *)self;

    if (obj->c_obj) {
        wips_blob_destroy(obj->c_obj);
        obj->c_obj = NULL;
    }

    Py_TYPE(self)->tp_free(self);
}


static PyObject *wips_blob_PyObject_new(PyTypeObject *type, PyObject *args, PyObject *kwds) {

    wips_blob_PyObject *self;

    self = (wips_blob_PyObject *)(type->tp_alloc(type,0));
    if (!self) {
        PyErr_NoMemory();
        return NULL;
    }
    self->c_obj = NULL;

    return (PyObject *)self;
}

static int wips_blob_PyObject_init(PyObject *self, PyObject *args, PyObject *kwds) {

    const char *buffer;
    Py_ssize_t py_size;
    size_t size;
    
    if (!PyArg_ParseTuple(args,"y#",&buffer,&py_size)) {
        return -1;
    }

    unsigned char size_status = pyssize_to_size(&size,py_size);
    if (size_status == WIPS_STATUS_UNDERFLOW){
        PyErr_SetString(PyExc_ValueError, "Negative buffer length");
        return -1;
    }

    wips_blob_PyObject *obj = (wips_blob_PyObject *)self;

    unsigned char *base = (unsigned char *)malloc(size);
    if (!base) {
        PyErr_NoMemory();
        return -1;
    }

    memcpy(base,buffer,size);
    wips_blob_t *c_blob = wips_blob_wrap(base,size);

    if (!c_blob) {
        free(base);
        PyErr_NoMemory();
        return -1;
    }

    obj->c_obj = c_blob;
    return 0;
}

wips_blob_PyObject *wips_blob_PyObject_create(wips_blob_t *blob) {
    wips_blob_PyObject *obj = (wips_blob_PyObject *)wips_blob_PyObject_new(
        &wips_blob_PyTypeObject,
        NULL,
        NULL
    );
    if (!obj) return NULL;
    obj->c_obj = blob;
    return obj;
}

static int wips_blob_PyObject_getbuffer(PyObject *self, Py_buffer *view, int flags) {
    wips_blob_PyObject *obj = (wips_blob_PyObject *)self;

    if (!obj->c_obj) {
        PyErr_SetString(PyExc_BufferError, "Underlying buffer is NULL");
        return -1;
    }

    view->buf = (void *)(obj->c_obj->base); 
    view->obj = self;
    view->readonly = 1;

    // Expose entire allocated buffer, since WIPS doesn't define size semantics beyond that
    view->len = obj->c_obj->allocated;
    Py_INCREF(self);

    view->itemsize = 1;
    view->ndim = 1;
    view->format = "B";
    view->shape = NULL; 
    view->strides = NULL;
    view->suboffsets = NULL;
    view->internal = NULL;

    return 0;
}

static PyObject *wips_blob_PyObject_get_offset(PyObject *self, void *closure) {
    wips_blob_PyObject *obj = (wips_blob_PyObject *)self;
    return PyLong_FromSize_t(obj->c_obj->offset);
}

static int wips_blob_PyObject_set_offset(PyObject *self, PyObject *value, void *closure) {
    wips_blob_PyObject *obj = (wips_blob_PyObject *)self;

    if (!PyLong_Check(value)) {
        PyErr_SetString(PyExc_TypeError, "The 'value' attribute must be an int");
        return -1;
    }

    size_t val = PyLong_AsSize_t(value);
    if (val == -1 && PyErr_Occurred()) {
        return -1;  // error converting
    }

    obj->c_obj->offset = val;
    return 0;
}

static PyBufferProcs wips_blob_PyObject_as_buffer = {
    .bf_getbuffer = wips_blob_PyObject_getbuffer,
    .bf_releasebuffer = NULL
};

static PyGetSetDef wips_blob_PyObject_getsetters[] = {
    {
        "offset",
        (getter)wips_blob_PyObject_get_offset,
        (setter)wips_blob_PyObject_set_offset,
        "int: the current offset of the blob",
        NULL
    },
    {NULL}
};

// vla methods
static void wips_vla_PyObject_dealloc(PyObject *self) {

    wips_vla_PyObject *obj = (wips_vla_PyObject *)self;

    if (obj->handler) {
        wips_PyHandler_decref(obj->handler);
        obj->wips_type = NULL;
        obj->handler = NULL;
        obj->c_vla.buffer_pt = NULL;
        obj->c_vla.vlasize_pt = NULL;
    }

    Py_TYPE(self)->tp_free(self);
}

wips_vla_PyObject *wips_vla_PyObject_create(wips_PyType *wips_type, wips_PyHandler *handler, wips_vlaref_t c_vla) {
    PyTypeObject *type = &wips_vla_PyTypeObject;
    wips_vla_PyObject *obj = (wips_vla_PyObject *)(type->tp_alloc(type,0));
    if (!obj) return NULL;
    wips_PyHandler_incref(handler);
    obj->c_vla = c_vla;
    obj->handler = handler;
    obj->wips_type = wips_type;
    return obj;
}


static Py_ssize_t wips_vla_PyObject_length(PyObject *self) {
    wips_vla_PyObject *obj = (wips_vla_PyObject *)self;
    Py_ssize_t pysize;
    wips_status_t size_status = size_to_pyssize(&pysize,*(obj->c_vla.vlasize_pt));
    if (size_status == WIPS_STATUS_OVERFLOW){
        PyErr_SetString(PyExc_OverflowError,"vla is too large");
        return -1;
    }
    return pysize;
}

static PyObject *wips_vla_PyObject_item(PyObject *self,Py_ssize_t index) {
    wips_vla_PyObject *obj = (wips_vla_PyObject *)self;

    // Calculate index
    size_t real_index;
    unsigned char index_status = pyssize_to_size(&real_index,index);
    if (index_status == WIPS_STATUS_UNDERFLOW) // index is negative, subtract from the end of the sequence
        real_index = *(obj->c_vla.vlasize_pt) - (size_t)(-index);

    // Extract raw C object from Python object
    void *c_value = obj->wips_type->vlamethods->getter(obj->c_vla,real_index);
    if (!c_value) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return NULL;
    }

    // Create non-owning view of object
    return obj->wips_type->wrapper(c_value,obj->handler);
}

static int wips_vla_PyObject_ass_item(PyObject *self, Py_ssize_t index, PyObject *value) {
    wips_vla_PyObject *obj = (wips_vla_PyObject *)self;

    if (Py_TYPE(value) != obj->wips_type->python_type) {
        PyErr_SetString(PyExc_TypeError, "Argument type must match VLA type");
        return -1;
    }

    // Calculate index
    size_t real_index;
    unsigned char index_status = pyssize_to_size(&real_index,index);
    if (index_status == WIPS_STATUS_UNDERFLOW) // index is negative, subtract from the end of the sequence
        real_index = *(obj->c_vla.vlasize_pt) - (size_t)(-index);

    void *old_value = obj->wips_type->vlamethods->getter(obj->c_vla,real_index);
    if (!old_value) {
        PyErr_SetString(PyExc_IndexError, "index out of range");
        return -1;
    }
    if (value) {
        void *new_value = obj->wips_type->creator();
        if (!new_value) {
            PyErr_SetString(
                PyExc_RuntimeError,
                "Failed to allocate element"
            );
            return -1;
        }
        wips_status_t copy_status = obj->wips_type->copier(
            new_value,
            obj->wips_type->unwrapper(value)
        );
        if (copy_status != WIPS_STATUS_OK) {
            PyErr_SetString(
                PyExc_RuntimeError,
                "Failed to copy element"
            );
            return -1;
        }
        wips_status_t ass_status = obj->wips_type->vlamethods->setter(
            obj->c_vla,
            real_index,
            new_value
        );
        free(new_value);
        if (ass_status != WIPS_STATUS_OK) {
            PyErr_SetString(
                PyExc_RuntimeError,
                "Failed to assign element"
            );
            return -1;
        }
        return 0;
    } else {
        // value is NULL, delete element
        wips_status_t status = obj->wips_type->vlamethods->setter(
            obj->c_vla,
            real_index,
            NULL
        );
        if (status != WIPS_STATUS_OK) {
            PyErr_SetString(
                PyExc_RuntimeError,
                "Failed to delete element"
            );
            return -1;
        }
        return 0;
    }
}

static PyObject *wips_vla_PyObject_elemtype(PyObject *self, PyObject *Py_UNUSED(ignored)) {
    wips_vla_PyObject *obj = (wips_vla_PyObject *)self;

    PyObject *typeobj = (PyObject *)(obj->wips_type->python_type);
    Py_INCREF(typeobj);
    return typeobj;
}

// Extracts a mutable python list of extracted structs from the VLA
static PyObject *wips_vla_PyObject_extract(PyObject *self) {
    wips_vla_PyObject *obj = (wips_vla_PyObject*)self;

    size_t length = *(obj->c_vla.vlasize_pt);
    Py_ssize_t pylength;
    
    wips_status_t len_status = (size_to_pyssize(&pylength,length));
    if (len_status == WIPS_STATUS_OVERFLOW) {
        PyErr_SetString(PyExc_OverflowError,"vla is too large");
        return NULL;
    }

    PyObject *list = PyList_New(pylength);
    if (!list) {
        return NULL;
    }

    size_t c_i = 0;
    for (Py_ssize_t i = 0; i < pylength; ++i) {
        void *elem = obj->wips_type->vlamethods->getter(
            obj->c_vla,
            c_i
        );
        if (!elem) {
            // OOB check
            Py_DECREF(list);
            PyErr_Format(
                PyExc_IndexError,
                "Index %zd is out of bounds", i
            );
            return NULL;
        }
        PyObject *extract_elem = obj->wips_type->extractor(elem);
        if (!extract_elem) {
            // NULL is only returned from an extractor on exception, no checking for error is needed
            Py_DECREF(list);
            return NULL;
        }
        PyList_SET_ITEM(list, i, extract_elem);

        ++c_i;
    }
    return list;
}


static PySequenceMethods wips_vla_seq_methods = {
    .sq_length = wips_vla_PyObject_length,
    .sq_concat = 0,
    .sq_repeat = 0,
    .sq_item = wips_vla_PyObject_item,
    .sq_ass_item = wips_vla_PyObject_ass_item,
    .sq_contains = 0,
    .sq_inplace_concat = 0,
    .sq_inplace_repeat = 0
};

static PyMethodDef wips_vla_methods[] = {
    {
        "elemtype",
        (PyCFunction)wips_vla_PyObject_elemtype,
        METH_NOARGS,
        PyDoc_STR("Return the Python type of the elements contained in this VLA.")
    },
    {NULL, NULL, 0, NULL} 
};

PyTypeObject wips_blob_PyTypeObject = {
    PyVarObject_HEAD_INIT(NULL,0)
    .tp_name = "wips.blob",
    .tp_doc = "Raw binary data blob",
    .tp_basicsize = sizeof(wips_blob_PyObject),
    .tp_dealloc = wips_blob_PyObject_dealloc,
    .tp_as_buffer = &wips_blob_PyObject_as_buffer,
    .tp_new = wips_blob_PyObject_new,
    .tp_init = (initproc)wips_blob_PyObject_init,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_getset = wips_blob_PyObject_getsetters
};

PyTypeObject wips_struct_PyTypeObject = {
    PyVarObject_HEAD_INIT(NULL,0)
    .tp_name = "wips.struct",
    .tp_basicsize = sizeof(wips_struct_PyObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
};

PyTypeObject wips_vla_PyTypeObject = {
    PyVarObject_HEAD_INIT(NULL,0)
    .tp_name = "wips.vla",
    .tp_doc = "Array of WIPS objects",
    .tp_basicsize = sizeof(wips_vla_PyObject),
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_as_sequence = &wips_vla_seq_methods,
    .tp_methods = wips_vla_methods
};



// TODO: more descriptive error messages?

// Primitive Impls

// These are for API compatibility, they shouldn't be used outside of that context
// Also, these pointers should not be freed manually

static inline PyObject *_wips_u8_wrap_impl(wips_u8_t val) {
    return PyLong_FromUnsignedLong((unsigned long)val);
}
static inline PyObject *_wips_i8_wrap_impl(wips_i8_t val) {
    return PyLong_FromLong((long)val);
}
static inline PyObject *_wips_u16_wrap_impl(wips_u16_t val) {
    return PyLong_FromUnsignedLong((unsigned long)val);
}
static inline PyObject *_wips_i16_wrap_impl(wips_i16_t val) {
    return PyLong_FromLong((long)val);
}
static inline PyObject *_wips_u32_wrap_impl(wips_u32_t val) {
    return PyLong_FromUnsignedLong((unsigned long)val);
}
static inline PyObject *_wips_i32_wrap_impl(wips_i32_t val) {
    return PyLong_FromLong((long)val);
}
static inline PyObject *_wips_u64_wrap_impl(wips_u64_t val) {
    return PyLong_FromUnsignedLongLong((unsigned long long)val);
}
static inline PyObject *_wips_i64_wrap_impl(wips_i64_t val) {
    return PyLong_FromLongLong((long long)val);
}
static inline PyObject *_wips_fp32_wrap_impl(wips_fp32_t val) {
    return PyFloat_FromDouble((double)val);
}
static inline PyObject *_wips_fp64_wrap_impl(wips_fp64_t val) {
    return PyFloat_FromDouble(val);
}

// u8
static inline void *_wips_u8_unwrap_impl(PyObject *obj) {
    static thread_local wips_u8_t buf;
    unsigned long tmp = PyLong_AsUnsignedLong(obj);
    if (tmp == (unsigned long)-1 && PyErr_Occurred()) {
        // Exception occurred, propagate it
        return NULL;
    }
    if (tmp > WIPS_u8_max) {
        PyErr_SetString(PyExc_OverflowError, "Argument is greater than u8 max value");
        return NULL;
    }
    buf = (wips_u8_t)tmp;
    return (void *)&buf;
}

// i8
static inline void *_wips_i8_unwrap_impl(PyObject *obj) {
    static thread_local wips_i8_t buf;
    long tmp = PyLong_AsLong(obj);
    if (tmp == (long)-1 && PyErr_Occurred()) {
        // Exception occurred, propagate
        return NULL;
    }
    if (tmp > WIPS_i8_max) {
        PyErr_SetString(PyExc_OverflowError, "Argument is greater than i8 max value");
        return NULL;
    }
    if (tmp < WIPS_i8_min) {
        PyErr_SetString(PyExc_ValueError, "Argument is less than i8 min value");
        return NULL;
    }
    buf = (wips_i8_t)tmp;
    return (void *)&buf;
}

// u16
static inline void *_wips_u16_unwrap_impl(PyObject *obj) {
    static thread_local wips_u16_t buf;
    unsigned long tmp = PyLong_AsUnsignedLong(obj);
    if (tmp == (unsigned long)-1 && PyErr_Occurred()) {
        // Exception occurred, propagate
        return NULL;
    }
    if (tmp > WIPS_u16_max) {
        PyErr_SetString(PyExc_OverflowError, "Argument is greater than u16 max value");
        return NULL;
    }
    buf = (wips_u16_t)tmp;
    return (void *)&buf;
}

// i16
static inline void *_wips_i16_unwrap_impl(PyObject *obj) {
    static thread_local wips_i16_t buf;
    long tmp = PyLong_AsLong(obj);
    if (tmp == (long)-1 && PyErr_Occurred()) {
        // Exception occurred, propagate
        return NULL;
    }
    if (tmp > WIPS_i16_max) {
        PyErr_SetString(PyExc_OverflowError, "Argument is greater than i16 max value");
        return NULL;
    }
    if (tmp < WIPS_i16_min) {
        PyErr_SetString(PyExc_ValueError, "Argument is less than i16 min value");
        return NULL;
    }
    buf = (wips_i16_t)tmp;
    return (void *)&buf;
}

// u32
static inline void *_wips_u32_unwrap_impl(PyObject *obj) {
    static thread_local wips_u32_t buf;
    unsigned long tmp = PyLong_AsUnsignedLong(obj);
    if (tmp == (unsigned long)-1 && PyErr_Occurred()) {
        // Exception occurred, propagate
        return NULL;
    }
    if (tmp > WIPS_u32_max) {
        PyErr_SetString(PyExc_OverflowError, "Argument is greater than u32 max value");
        return NULL;
    }
    buf = (wips_u32_t)tmp;
    return (void *)&buf;
}

// i32
static inline void *_wips_i32_unwrap_impl(PyObject *obj) {
    static thread_local wips_i32_t buf;
    long tmp = PyLong_AsLong(obj);
    if (tmp == (long)-1 && PyErr_Occurred()) {
        // Exception occurred, propagate
        return NULL;
    }
    if (tmp > WIPS_i32_max) {
        PyErr_SetString(PyExc_OverflowError, "Argument is greater than i32 max value");
        return NULL;
    }
    if (tmp < WIPS_i32_min) {
        PyErr_SetString(PyExc_ValueError, "Argument is less than i32 min value");
        return NULL;
    }
    buf = (wips_i32_t)tmp;
    return (void *)&buf;
}

// u64
static inline void *_wips_u64_unwrap_impl(PyObject *obj) {
    static thread_local wips_u64_t buf;
    unsigned long long tmp = PyLong_AsUnsignedLongLong(obj);
    if (tmp == (unsigned long long)-1 && PyErr_Occurred()) {
        // Exception occurred, propagate
        return NULL;
    }
    if (tmp > WIPS_u64_max) {
        PyErr_SetString(PyExc_OverflowError, "Argument is greater than u64 max value");
        return NULL;
    }
    buf = (wips_u64_t)tmp;
    return (void *)&buf;
}

// i64
static inline void *_wips_i64_unwrap_impl(PyObject *obj) {
    static thread_local wips_i64_t buf;
    long long tmp = PyLong_AsLongLong(obj);
    if (tmp == (long long)-1 && PyErr_Occurred()) {
        // Exception occurred, propagate
        return NULL;
    }
    if (tmp > WIPS_i64_max) {
        PyErr_SetString(PyExc_OverflowError, "Argument is greater than i64 max value");
        return NULL;
    }
    if (tmp < WIPS_i64_min) {
        PyErr_SetString(PyExc_ValueError, "Argument is less than i64 min value");
        return NULL;
    }
    buf = (wips_i64_t)tmp;
    return (void *)&buf;
}

// fp32
static inline void *_wips_fp32_unwrap_impl(PyObject *obj) {
    static thread_local wips_fp32_t buf;
    double tmp = PyFloat_AsDouble(obj);
    if (tmp == (double)-1.0 && PyErr_Occurred()) {
        // Exception occurred, propagate
        return NULL;
    }
    if (tmp > WIPS_fp32_max) {
        PyErr_SetString(PyExc_OverflowError, "Argument is greater than fp32 max value");
        return NULL;
    }
    if (tmp < WIPS_fp32_min) {
        PyErr_SetString(PyExc_ValueError, "Argument is less than fp32 min value");
        return NULL;
    }
    buf = (wips_fp32_t)tmp;
    return (void *)&buf;
}

// fp64
static inline void *_wips_fp64_unwrap_impl(PyObject *obj) {
    static thread_local wips_fp64_t buf;
    double tmp = PyFloat_AsDouble(obj);
    if (tmp == (double)-1.0 && PyErr_Occurred()) {
        // Exception occurred, propagate
        return NULL;
    }
    if (tmp > WIPS_fp64_max) {
        PyErr_SetString(PyExc_OverflowError, "Argument is greater than fp64 max value");
        return NULL;
    }
    if (tmp < WIPS_fp64_min) {
        PyErr_SetString(PyExc_ValueError, "Argument is less than fp63 min value");
        return NULL;
    }
    buf = (wips_fp64_t)tmp;
    return (void *)&buf;
}

#define DEFINE_PRIMITIVE_CREATOR(wips_typename)                                             \
    static void *wips_ ## wips_typename ## _create(){                                       \
        static thread_local unsigned char buf[GET_SIZE(wips_typename)];                     \
        return (void *)&buf;                                                                \
    }

#define DEFINE_PRIMITIVE_DESTRUCTOR(wips_typename)                                          \
    static void wips_ ## wips_typename ## _destroy(void *obj){                              \
        return;                                                                             \
    }

#define DEFINE_PRIMITIVE_WRAPPER(wips_typename)                                             \
    static PyObject *wips_ ## wips_typename ## _wrap(void *obj,wips_PyHandler* handler){    \
        GET_CTYPE(wips_typename) val = *((GET_CTYPE(wips_typename) *)obj);                  \
        return _wips_ ## wips_typename ## _wrap_impl(val);                                  \
    }

#define DEFINE_PRIMITIVE_UNWRAPPER(wips_typename)                                           \
    static void *wips_ ## wips_typename ## _unwrap(PyObject *obj) {                         \
        return _wips_ ## wips_typename ## _unwrap_impl(obj);                                \
    }

#define DEFINE_PRIMITIVE_EXTRACTOR(wips_typename)                                           \
    static PyObject *wips_ ## wips_typename ## _extract(void *obj) {                        \
        GET_CTYPE(wips_typename) val = *((GET_CTYPE(wips_typename) *)obj);                  \
        return _wips_ ## wips_typename ## _wrap_impl(val);                                  \
    }

DEFINE_PRIMITIVE_CREATOR(u8)
DEFINE_PRIMITIVE_DESTRUCTOR(u8)
DEFINE_PRIMITIVE_WRAPPER(u8)
DEFINE_PRIMITIVE_UNWRAPPER(u8)
DEFINE_PRIMITIVE_EXTRACTOR(u8)
wips_PyType wips_u8_PyType = {
    .type_id = WIPS_u8,
    .size = 1,
    .python_type = &PyLong_Type,
    .vlamethods = &wips_u8_vlamethods,
    .creator = wips_u8_create,
    .destructor = wips_u8_destroy,
    .wrapper = wips_u8_wrap,
    .unwrapper = wips_u8_unwrap,
    .extractor = wips_u8_extract
};

DEFINE_PRIMITIVE_CREATOR(i8)
DEFINE_PRIMITIVE_DESTRUCTOR(i8)
DEFINE_PRIMITIVE_WRAPPER(i8)
DEFINE_PRIMITIVE_UNWRAPPER(i8)
DEFINE_PRIMITIVE_EXTRACTOR(i8)
wips_PyType wips_i8_PyType = {
    .type_id = WIPS_i8,
    .size = 1,
    .python_type = &PyLong_Type,
    .vlamethods = &wips_i8_vlamethods,
    .creator = wips_i8_create,
    .destructor = wips_i8_destroy,
    .wrapper = wips_i8_wrap,
    .unwrapper = wips_i8_unwrap,
    .extractor = wips_i8_extract
};

DEFINE_PRIMITIVE_CREATOR(u16)
DEFINE_PRIMITIVE_DESTRUCTOR(u16)
DEFINE_PRIMITIVE_WRAPPER(u16)
DEFINE_PRIMITIVE_UNWRAPPER(u16)
DEFINE_PRIMITIVE_EXTRACTOR(u16)
wips_PyType wips_u16_PyType = {
    .type_id = WIPS_u16,
    .size = 2,
    .python_type = &PyLong_Type,
    .vlamethods = &wips_u16_vlamethods,
    .creator = wips_u16_create,
    .destructor = wips_u16_destroy,
    .wrapper = wips_u16_wrap,
    .unwrapper = wips_u16_unwrap,
    .extractor = wips_u16_extract
};

DEFINE_PRIMITIVE_CREATOR(i16)
DEFINE_PRIMITIVE_DESTRUCTOR(i16)
DEFINE_PRIMITIVE_WRAPPER(i16)
DEFINE_PRIMITIVE_UNWRAPPER(i16)
DEFINE_PRIMITIVE_EXTRACTOR(i16)
wips_PyType wips_i16_PyType = {
    .type_id = WIPS_i16,
    .size = 2,
    .python_type = &PyLong_Type,
    .vlamethods = &wips_i16_vlamethods,
    .creator = wips_i16_create,
    .destructor = wips_i16_destroy,
    .wrapper = wips_i16_wrap,
    .unwrapper = wips_i16_unwrap,
    .extractor = wips_i16_extract
};

DEFINE_PRIMITIVE_CREATOR(u32)
DEFINE_PRIMITIVE_DESTRUCTOR(u32)
DEFINE_PRIMITIVE_WRAPPER(u32)
DEFINE_PRIMITIVE_UNWRAPPER(u32)
DEFINE_PRIMITIVE_EXTRACTOR(u32)
wips_PyType wips_u32_PyType = {
    .type_id = WIPS_u32,
    .size = 4,
    .python_type = &PyLong_Type,
    .vlamethods = &wips_u32_vlamethods,
    .creator = wips_u32_create,
    .destructor = wips_u32_destroy,
    .wrapper = wips_u32_wrap,
    .unwrapper = wips_u32_unwrap,
    .extractor = wips_u32_extract
};

DEFINE_PRIMITIVE_CREATOR(i32)
DEFINE_PRIMITIVE_DESTRUCTOR(i32)
DEFINE_PRIMITIVE_WRAPPER(i32)
DEFINE_PRIMITIVE_UNWRAPPER(i32)
DEFINE_PRIMITIVE_EXTRACTOR(i32)
wips_PyType wips_i32_PyType = {
    .type_id = WIPS_i32,
    .size = 4,
    .python_type = &PyLong_Type,
    .vlamethods = &wips_i32_vlamethods,
    .creator = wips_i32_create,
    .destructor = wips_i32_destroy,
    .wrapper = wips_i32_wrap,
    .unwrapper = wips_i32_unwrap,
    .extractor = wips_i32_extract
};

DEFINE_PRIMITIVE_CREATOR(u64)
DEFINE_PRIMITIVE_DESTRUCTOR(u64)
DEFINE_PRIMITIVE_WRAPPER(u64)
DEFINE_PRIMITIVE_UNWRAPPER(u64)
DEFINE_PRIMITIVE_EXTRACTOR(u64)
wips_PyType wips_u64_PyType = {
    .type_id = WIPS_u64,
    .size = 8,
    .python_type = &PyLong_Type,
    .vlamethods = &wips_u64_vlamethods,
    .creator = wips_u64_create,
    .destructor = wips_u64_destroy,
    .wrapper = wips_u64_wrap,
    .unwrapper = wips_u64_unwrap,
    .extractor = wips_u64_extract
};

DEFINE_PRIMITIVE_CREATOR(i64)
DEFINE_PRIMITIVE_DESTRUCTOR(i64)
DEFINE_PRIMITIVE_WRAPPER(i64)
DEFINE_PRIMITIVE_UNWRAPPER(i64)
DEFINE_PRIMITIVE_EXTRACTOR(i64)
wips_PyType wips_i64_PyType = {
    .type_id = WIPS_i64,
    .size = 8,
    .python_type = &PyLong_Type,
    .vlamethods = &wips_i64_vlamethods,
    .creator = wips_i64_create,
    .destructor = wips_i64_destroy,
    .wrapper = wips_i64_wrap,
    .unwrapper = wips_i64_unwrap,
    .extractor = wips_i64_extract
};

DEFINE_PRIMITIVE_CREATOR(fp32)
DEFINE_PRIMITIVE_DESTRUCTOR(fp32)
DEFINE_PRIMITIVE_WRAPPER(fp32)
DEFINE_PRIMITIVE_UNWRAPPER(fp32)
DEFINE_PRIMITIVE_EXTRACTOR(fp32)
wips_PyType wips_fp32_PyType = {
    .type_id = WIPS_fp32,
    .size = 4,
    .python_type = &PyFloat_Type,
    .vlamethods = &wips_fp32_vlamethods,
    .creator = wips_fp32_create,
    .destructor = wips_fp32_destroy,
    .wrapper = wips_fp32_wrap,
    .unwrapper = wips_fp32_unwrap,
    .extractor = wips_fp32_extract
};

DEFINE_PRIMITIVE_CREATOR(fp64)
DEFINE_PRIMITIVE_DESTRUCTOR(fp64)
DEFINE_PRIMITIVE_WRAPPER(fp64)
DEFINE_PRIMITIVE_UNWRAPPER(fp64)
DEFINE_PRIMITIVE_EXTRACTOR(fp64)
wips_PyType wips_fp64_PyType = {
    .type_id = WIPS_fp64,
    .size = 8,
    .python_type = &PyFloat_Type,
    .vlamethods = &wips_fp64_vlamethods,
    .creator = wips_fp64_create,
    .destructor = wips_fp64_destroy,
    .wrapper = wips_fp64_wrap,
    .unwrapper = wips_fp64_unwrap,
    .extractor = wips_fp64_extract
};

// Type objects
#ifdef __cplusplus
}
#endif

#endif // WIPS_OPTION_BUILD_PYTHON
