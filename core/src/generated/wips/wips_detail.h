/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2025 Jesse Kane
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

// This file was automatically generated by WIPS. Do not attempt to modify manually

// INTERNAL HEADER — DO NOT INCLUDE DIRECTLY
//
// This file is part of the internal implementation of WIPS and is not
// intended for direct use by users. Its contents may change at any time
// without notice, and no support or documentation is guaranteed for
// applications that include this file manually.

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WIPS_INTERNAL
    #warning "wips_detail.h is an INTERNAL HEADER! It should NOT be included directly in public code"
#endif

#include "wips_runtime.h"
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stddef.h>

#if defined(_MSC_VER)
    #define wips_htonll(x) _byteswap_uint64(x)
    #define wips_ntohll(x) _byteswap_uint64(x)
#elif defined(__GNUC__) || defined(__clang__)
    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
        // little endian
        #define wips_htonll(x) __builtin_bswap64(x)
        #define wips_ntohll(x) __builtin_bswap64(x)
    #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
        // big endian
        #define wips_htonll(x) (x)
        #define wips_ntohll(x) (x)
    #endif
    
#else
    static inline uint64_t bswap64(uint64_t x) {
        return  ((x & 0xFF00000000000000ULL) >> 56) |
                ((x & 0x00FF000000000000ULL) >> 40) |
                ((x & 0x0000FF0000000000ULL) >> 24) |
                ((x & 0x000000FF00000000ULL) >> 8)  |
                ((x & 0x00000000FF000000ULL) << 8)  |
                ((x & 0x0000000000FF0000ULL) << 24) |
                ((x & 0x000000000000FF00ULL) << 40) |
                ((x & 0x00000000000000FFULL) << 56);
    }
    #define wips_htonll(x) bswap64(x)
    #define wips_ntohll(x) bswap64(x)
#endif

#if defined(_WIN32)
    #include <winsock2.h>
#elif defined (__unix__) || (defined (__APPLE__) && defined (__MACH__))
    #include <arpa/inet.h>
#endif

#define wips_htonl(x) htonl(x)
#define wips_ntohl(x) ntohl(x)
#define wips_htons(x) htons(x)
#define wips_ntohs(x) ntohs(x)

#define EXPAND(x) x
#define CONCAT3(a, b, c) a ## b ## c
#define EXPAND_CONCAT3(a, b, c) CONCAT3(a, b, c)

#define GET_CTYPE(wips_typename) EXPAND_CONCAT3(wips_, wips_typename, _t)
#define GET_SIZE(wips_typename) sizeof(GET_CTYPE(wips_typename))

#define GET_DETAIL_IMPL(field,detail) DETAIL ## detail ## __ ## field
#define GET_DETAIL(field,detail) GET_DETAIL_IMPL(field,detail)

#define STRINGIZE_IMPL(x) #x
#define STRINGIZE(x) STRINGIZE_IMPL(x)

// Portable thread-safe version of localtime()
struct tm* wips_localtime(const time_t* timer);

#ifndef NDEBUG

#include <stdio.h>
#include <time.h>

#define WIPS_DEBUGLOG(fmt,...)                                                                                  \
    do {                                                                                                        \
        time_t now = time(NULL);                                                                                \
        if (now == ((time_t)-1)) {                                                                              \
            perror("time");                                                                                     \
            break;                                                                                              \
        }                                                                                                       \
        struct tm *local = wips_localtime(&now);                                                                \
        if (local == NULL) {                                                                                    \
            perror("localtime");                                                                                \
            break;                                                                                              \
        }                                                                                                       \
        char timestr[32];                                                                                       \
        if (strftime(timestr, sizeof(timestr), "%Y-%m-%d %H:%M:%S", local) == 0) {                              \
            strcpy(timestr, "TIME-FAIL");                                                                       \
        }                                                                                                       \
        fprintf(stderr, "[%s] [WIPS]: ", timestr);                                                              \
        fprintf(stderr, fmt __VA_OPT__(,) __VA_ARGS__);                                                         \
    } while (0)

#define WIPS_Assert(expr, bytes_processed)                                                                      \
    do {                                                                                                        \
        if (!(expr)){                                                                                           \
            WIPS_DEBUGLOG("Assertion failed: %s, file %s, line %d\n",STRINGIZE(expr),__FILE__,__LINE__);        \
            return wips_make_result(bytes_processed,WIPS_STATUS_BAD_ASSERT);                                    \
        }                                                                                                       \
    } while (0)

#define WIPS_FatalAssert(expr)                                                                                  \
   do {                                                                                                         \
        if (!(expr)){                                                                                           \
            WIPS_DEBUGLOG("Fatal assertion failed: %s, file %s, line %d\n",STRINGIZE(expr),__FILE__,__LINE__);  \
            abort();                                                                                            \
        }                                                                                                       \
    } while (0)


#ifdef WIPS_OPTION_TRACEBACK

#define WIPS_TRACELOG(fmt,...)                                                                                  \
    do {                                                                                                        \
        time_t now = time(NULL);                                                                                \
        if (now == ((time_t)-1)) {                                                                              \
            perror("time");                                                                                     \
            break;                                                                                              \
        }                                                                                                       \
        struct tm *local = wips_localtime(&now);                                                                \
        if (local == NULL) {                                                                                    \
            perror("localtime");                                                                                \
            break;                                                                                              \
        }                                                                                                       \
        char timestr[32];                                                                                       \
        if (strftime(timestr, sizeof(timestr), "%Y-%m-%d %H:%M:%S", local) == 0) {                              \
            strcpy(timestr, "TIME-FAIL");                                                                       \
        }                                                                                                       \
        fprintf(stderr, "[%s] [WIPS_TRACE]: ", timestr);                                                        \
        fprintf(stderr, fmt __VA_OPT__(,) __VA_ARGS__);                                                         \
    } while (0)

#else

#define WIPS_TRACELOG(fmt,...)

#endif // WIPS_OPTION_TRACEBACK

#else

#define WIPS_DEBUGLOG(fmt,...)
#define WIPS_TRACELOG(fmt,...)
#define WIPS_Assert(expr, bytes_processed)
#define WIPS_FatalAssert(expr)

#endif // NDEBUG

#define DEFINE_TRIVIAL_ENCODE(wips_typename)                                                                    \
    wips_result_t wips_encode_##wips_typename(wips_blob_t* data, GET_CTYPE(wips_typename)* in){                 \
        WIPS_Assert(data != NULL && in != NULL,0);                                                              \
        WIPS_TRACELOG("Encoding %s\n",STRINGIZE(wips_typename));                                                \
        if (data->offset > (SIZE_MAX - GET_SIZE(wips_typename))){                                               \
            WIPS_DEBUGLOG("Fatal error while encoding %s: Integer overflow\n",STRINGIZE(wips_typename));        \
            return wips_make_result(0,WIPS_STATUS_OVERFLOW);                                                    \
        }                                                                                                       \
        size_t newOffset = data->offset + GET_SIZE(wips_typename);                                              \
        if (newOffset > data->allocated) {                                                                      \
            WIPS_DEBUGLOG("Reallocation triggered while encoding %s\n",STRINGIZE(wips_typename));               \
            size_t new_allocated = data->allocated * 2 >= newOffset                                             \
                ? data->allocated * 2                                                                           \
                : newOffset;                                                                                    \
            unsigned char* newBase = realloc(data->base, new_allocated);                                        \
            if (!newBase) {                                                                                     \
                WIPS_DEBUGLOG("Fatal error while encoding %s: OOM\n",STRINGIZE(wips_typename));                 \
                return wips_make_result(0,WIPS_STATUS_OOM);                                                     \
            }                                                                                                   \
            data->allocated = new_allocated;                                                                    \
            data->base = newBase;                                                                               \
        }                                                                                                       \
        memcpy(data->base+data->offset, in, GET_SIZE(wips_typename));                                           \
        data->offset = newOffset;                                                                               \
        WIPS_TRACELOG("Finished encoding %s\n",STRINGIZE(wips_typename));                                       \
        return wips_make_result(GET_SIZE(wips_typename),WIPS_STATUS_OK);                                        \
    }

#define DEFINE_TRIVIAL_ENCODE_NRB(wips_typename)                                                                \
    wips_result_t wips_encode_nrb_##wips_typename(wips_blob_t* data, GET_CTYPE(wips_typename)* in){             \
        WIPS_Assert(in != NULL && data != NULL,0);                                                              \
        WIPS_TRACELOG("No resize buffer (nrb) encoding %s\n",STRINGIZE(wips_typename));                         \
        if (data->offset > (SIZE_MAX - GET_SIZE(wips_typename))){                                               \
            WIPS_DEBUGLOG("Fatal error while nrb encoding %s: Integer overflow\n",STRINGIZE(wips_typename));    \
            return wips_make_result(0,WIPS_STATUS_OVERFLOW);                                                    \
        }                                                                                                       \
        size_t newOffset = data->offset + GET_SIZE(wips_typename);                                              \
        if (newOffset > data->allocated){                                                                       \
            WIPS_DEBUGLOG("Fatal error while nrb encoding %s: Buffer overflow\n",STRINGIZE(wips_typename));     \
            return wips_make_result(0,WIPS_STATUS_BUF_OVERFLOW);                                                \
        }                                                                                                       \
        memcpy(data->base+data->offset, in, GET_SIZE(wips_typename));                                           \
        data->offset = newOffset;                                                                               \
        WIPS_TRACELOG("Finished nrb encoding %s\n",STRINGIZE(wips_typename));                                   \
        return wips_make_result(GET_SIZE(wips_typename),WIPS_STATUS_OK);                                        \
    }
    
#define DEFINE_TRIVIAL_DECODE(wips_typename)                                                                    \
    wips_result_t wips_decode_##wips_typename(GET_CTYPE(wips_typename)* out, wips_blob_t* data){                \
        WIPS_Assert(out != NULL && data != NULL,0);                                                             \
        WIPS_TRACELOG("Decoding %s\n",STRINGIZE(wips_typename));                                                \
        if (data->offset > (SIZE_MAX - GET_SIZE(wips_typename))){                                               \
            WIPS_DEBUGLOG("Fatal error while decoding %s: Integer overflow\n",STRINGIZE(wips_typename));        \
            return wips_make_result(0,WIPS_STATUS_OVERFLOW);                                                    \
        }                                                                                                       \
        size_t newOffset = data->offset + GET_SIZE(wips_typename);                                              \
        if (newOffset > data->allocated){                                                                       \
            WIPS_DEBUGLOG("Fatal error while decoding %s: Out-of-bounds error\n",STRINGIZE(wips_typename));     \
            return wips_make_result(0,WIPS_STATUS_BOUNDS_ERROR);                                                \
        }                                                                                                       \
        memcpy(out,data->base+data->offset, GET_SIZE(wips_typename));                                           \
        data->offset = newOffset;                                                                               \
        WIPS_TRACELOG("Finished decoding %s\n",STRINGIZE(wips_typename));                                       \
        return wips_make_result(GET_SIZE(wips_typename),WIPS_STATUS_OK);                                        \
    }

#define DEFINE_VLAGETTER(wips_typename)                                                                         \
    static void* wips_ ## wips_typename ## _vlagetter(wips_vlaref_t vla, size_t index) {                        \
        if (index >= *(vla.vlasize_pt)) return NULL;                                                            \
        GET_CTYPE(wips_typename) **buffer_ptr =                                                                 \
            (GET_CTYPE(wips_typename) **)(vla.buffer_pt);                                                       \
        GET_CTYPE(wips_typename) *buffer = *buffer_ptr;                                                         \
        return (void *)(buffer + index);                                                                        \
    }

#define DEFINE_VLASETTER(wips_typename)\
    static wips_status_t wips_ ## wips_typename ## _vlasetter(wips_vlaref_t vla, size_t index, void *value) {   \
        if (index >= *(vla.vlasize_pt)) return WIPS_STATUS_BOUNDS_ERROR;                                        \
        GET_CTYPE(wips_typename) **buffer_ptr =                                                                 \
            (GET_CTYPE(wips_typename) **)(vla.buffer_pt);                                                       \
        GET_CTYPE(wips_typename) *buffer = *buffer_ptr;                                                         \
        GET_CTYPE(wips_typename) *old_value = buffer + index;                                                   \
        if (value) {                                                                                            \
            memcpy(old_value, value, GET_SIZE(wips_typename));                                                  \
            return WIPS_STATUS_OK;                                                                              \
        } else {                                                                                                \
            size_t count_after = *(vla.vlasize_pt) - index - 1;                                                 \
            if (count_after > 0)                                                                                \
                memmove(old_value, old_value + 1, count_after * GET_SIZE(wips_typename));                       \
            (*vla.vlasize_pt)--;                                                                                \
            size_t newalloc = (*vla.vlasize_pt) * GET_SIZE(wips_typename);                                      \
            GET_CTYPE(wips_typename) *newbuffer =                                                               \
                (GET_CTYPE(wips_typename) *)realloc(buffer, newalloc);                                          \
            if (!newbuffer) return WIPS_STATUS_OOM;                                                             \
            *buffer_ptr = newbuffer;                                                                            \
            return WIPS_STATUS_OK;                                                                              \
        }                                                                                                       \
    }

#define DEFINE_VLAPUSHBACK(wips_typename)                                                                       \
    static wips_status_t wips_ ## wips_typename ## _vlapushback(wips_vlaref_t vla, void *value) {               \
        if (!value) return WIPS_STATUS_OK;                                                                      \
        GET_CTYPE(wips_typename) **buffer_ptr =                                                                 \
            (GET_CTYPE(wips_typename) **)(vla.buffer_pt);                                                       \
        GET_CTYPE(wips_typename) *buffer = *buffer_ptr;                                                         \
        size_t newsize = (*vla.vlasize_pt) + 1;                                                                 \
        GET_CTYPE(wips_typename) *newbuffer =                                                                   \
            realloc(buffer,newsize * GET_SIZE(wips_typename));                                                  \
        if (!newbuffer) return WIPS_STATUS_OOM;                                                                 \
        size_t offset = (*vla.vlasize_pt);                                                                      \
        memcpy(newbuffer + offset,value,GET_SIZE(wips_typename));                                               \
        *buffer_ptr = newbuffer;                                                                                \
        (*vla.vlasize_pt) = newsize;                                                                            \
        return WIPS_STATUS_OK;                                                                                  \
    }

// Technically this doesn't need to be passed pointers, but it matches the semantics of the rest of the program
// This isn't ALGOL-60, call-by-name semantics is not something I want to think about
#define GET_VLAREF(out,wips_typename,wips_struct,field)                                                         \
    do {                                                                                                        \
        wips_u32_t *vlasize_pt = &((wips_struct)->GET_DETAIL(field,vlasize));                                   \
        void *buffer_pt = (void *)(&((wips_struct)->field));                                                    \
        (out)->vlasize_pt = vlasize_pt;                                                                         \
        (out)->buffer_pt = buffer_pt;                                                                           \
    } while (0)

#ifdef __cplusplus
}
#endif