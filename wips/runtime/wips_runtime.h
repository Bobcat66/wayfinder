/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2025 Jesse Kane
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

// This file was automatically generated by WIPS. Do not attempt to modify manually

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <float.h>

// More user-friendly macro for accessing WIPS details than the ones used internally.
#define GET_WIPS_DETAIL_IMPL(field,detail) DETAIL ## detail ## __ ## field
#define GET_WIPS_DETAIL(wips_struct,field,detail) (wips_struct)->GET_WIPS_DETAIL_IMPL(field,detail)

// Status codes
#define WIPS_STATUS_OK 0x00 // No error
#define WIPS_STATUS_OOM 0x01  // out of memory
#define WIPS_STATUS_BOUNDS_ERROR 0x02 // Out-of-bounds error
#define WIPS_STATUS_OVERFLOW 0x03 // Overflow error
#define WIPS_STATUS_BAD_ASSERT 0x04 // Failed assertion
#define WIPS_STATUS_UNDERFLOW 0x05 // Underflow error
#define WIPS_STATUS_BUF_OVERFLOW 0x06 // Buffer overflow
#define WIPS_STATUS_UNKNOWN 0xff // Unknown error

typedef unsigned char wips_status_t;

typedef uint8_t wips_u8_t;
#define WIPS_u8_max UINT8_MAX
#define WIPS_u8_min 0

typedef int8_t wips_i8_t;
#define WIPS_i8_max INT8_MAX
#define WIPS_i8_min INT8_MIN

typedef uint16_t wips_u16_t;
#define WIPS_u16_max UINT16_MAX
#define WIPS_u16_min 0

typedef int16_t wips_i16_t;
#define WIPS_i16_max INT16_MAX
#define WIPS_i16_min INT16_MIN

typedef uint32_t wips_u32_t;
#define WIPS_u32_max UINT32_MAX
#define WIPS_u32_min 0

typedef int32_t wips_i32_t;
#define WIPS_i32_max INT32_MAX
#define WIPS_i32_min INT32_MIN

typedef uint64_t wips_u64_t;
#define WIPS_u64_max UINT64_MAX
#define WIPS_u64_min 0

typedef int64_t wips_i64_t;
#define WIPS_i64_max INT64_MAX
#define WIPS_i64_min INT64_MIN

typedef float wips_fp32_t;
#define WIPS_fp32_max FLT_MAX
#define WIPS_fp32_min (-FLT_MAX)

typedef double wips_fp64_t;
#define WIPS_fp64_max DBL_MAX
#define WIPS_fp64_min (-DBL_MAX)

typedef struct {
    size_t bytes_processed;
    wips_status_t status_code;
} wips_result_t;

static inline wips_result_t wips_make_result(size_t bytes, wips_status_t code) {
    wips_result_t r;
    r.bytes_processed = bytes;
    r.status_code = code;
    return r;
}

// Metadata and reflection code

typedef struct wips_vlaref wips_vlaref_t;
typedef struct wips_vlamethods wips_vlamethods_t;

// Allows type-erased manipulation of VLAs. NOTE: A ref does NOT own the vla, the vla is still owned by the wips struct.
// Refs are invalidated when the wips struct that owns the VLA is destroyed. vlarefs CAN mutate the VLA and its metadata,
// however.
struct wips_vlaref {
    void *buffer_pt; // A double pointer to the buffer, type-erased to void*
    wips_u32_t *vlasize_pt; // a pointer to the vlasize field
};

// Holds methods for manipulating VLAs of a given type, with type erasure
struct wips_vlamethods {
    // takes a pointer to the output, a vlaref, and an index.
    // returns a pointer to the object. the Caller does NOT own the returned pointer
    // returns NULL if the index is out of bounds
    void *(* const getter)(wips_vlaref_t, size_t);
    // If the value pointer is NULL, the element at the index will be deleted. Otherwise,
    // A shallow copy of the memory referenced by the value pointer will be copied into the VLA
    // (a direct memcpy). Will resize if needed
    wips_status_t (* const setter)(wips_vlaref_t, size_t, void *);
    // Appends value to end of VLA, resizing if needed. If the value pointer is NULL, this is a no-op
    wips_status_t (* const pushback)(wips_vlaref_t, void *);
};

typedef struct {
    unsigned char* base;
    size_t offset; // the offset from the base pointer to the part of the wips_blob we actually care about.
    size_t allocated; // The amount of memory allocated
} wips_blob_t;

// Dynamically allocates a blob. In general, blobs created with wips_blob_create are the
// safest to use, and have the fewest footguns. Use this unless you know what you're doing
wips_blob_t *wips_blob_create(size_t size);

// Deprecated for public use, For internal use only. Use wips_blob_stackwrap instead
wips_blob_t *wips_blob_wrap(unsigned char *base, size_t size);

// Creates a blob on the stack. Blobs created with this method cannot be destroyed normally
// The caller is in charge of lifetime ownership for the base pointer
wips_blob_t wips_blob_stackwrap(unsigned char *base, size_t size);

void wips_blob_destroy(wips_blob_t *bin);

wips_result_t wips_encode_u8(wips_blob_t *data, wips_u8_t *in);
wips_result_t wips_encode_nrb_u8(wips_blob_t *data, wips_u8_t *in);
wips_result_t wips_decode_u8(wips_u8_t *out, wips_blob_t *data);

wips_result_t wips_encode_i8(wips_blob_t *data, wips_i8_t *in);
wips_result_t wips_encode_nrb_i8(wips_blob_t *data, wips_i8_t *in);
wips_result_t wips_decode_i8(wips_i8_t *out, wips_blob_t *data);

wips_result_t wips_encode_u16(wips_blob_t *data, wips_u16_t *in);
wips_result_t wips_encode_nrb_u16(wips_blob_t *data, wips_u16_t *in);
wips_result_t wips_decode_u16(wips_u16_t *out, wips_blob_t *data);

wips_result_t wips_encode_i16(wips_blob_t *data, wips_i16_t *in);
wips_result_t wips_encode_nrb_i16(wips_blob_t *data, wips_i16_t *in);
wips_result_t wips_decode_i16(wips_i16_t *out, wips_blob_t *data);

wips_result_t wips_encode_u32(wips_blob_t *data, wips_u32_t *in);
wips_result_t wips_encode_nrb_u32(wips_blob_t *data, wips_u32_t *in);
wips_result_t wips_decode_u32(wips_u32_t *out, wips_blob_t *data);

wips_result_t wips_encode_i32(wips_blob_t *data, wips_i32_t *in);
wips_result_t wips_encode_nrb_i32(wips_blob_t *data, wips_i32_t *in);
wips_result_t wips_decode_i32(wips_i32_t *out, wips_blob_t *data);

wips_result_t wips_encode_u64(wips_blob_t *data, wips_u64_t *in);
wips_result_t wips_encode_nrb_u64(wips_blob_t *data, wips_u64_t *in);
wips_result_t wips_decode_u64(wips_u64_t *out, wips_blob_t *data);

wips_result_t wips_encode_i64(wips_blob_t *data, wips_i64_t *in);
wips_result_t wips_encode_nrb_i64(wips_blob_t *data, wips_i64_t *in);
wips_result_t wips_decode_i64(wips_i64_t *out, wips_blob_t *data);


wips_result_t wips_encode_fp32(wips_blob_t *data, wips_fp32_t *in);
wips_result_t wips_encode_nrb_fp32(wips_blob_t *data, wips_fp32_t *in);
wips_result_t wips_decode_fp32(wips_fp32_t *out, wips_blob_t *data);

wips_result_t wips_encode_fp64(wips_blob_t *data, wips_fp64_t *in);
wips_result_t wips_encode_nrb_fp64(wips_blob_t *data, wips_fp64_t *in);
wips_result_t wips_decode_fp64(wips_fp64_t *out, wips_blob_t *data);

void wips_u8_free_resources(wips_u8_t *data);
void wips_i8_free_resources(wips_i8_t *data);
void wips_u16_free_resources(wips_u16_t *data);
void wips_i16_free_resources(wips_i16_t *data);
void wips_u32_free_resources(wips_u32_t *data);
void wips_i32_free_resources(wips_i32_t *data);
void wips_u64_free_resources(wips_u64_t *data);
void wips_i64_free_resources(wips_i64_t *data);
void wips_fp32_free_resources(wips_fp32_t *data);
void wips_fp64_free_resources(wips_fp64_t *data);

wips_status_t wips_u8_copy(wips_u8_t *dest, const wips_u8_t *src);
wips_status_t wips_i8_copy(wips_i8_t *dest, const wips_i8_t *src);
wips_status_t wips_u16_copy(wips_u16_t *dest, const wips_u16_t *src);
wips_status_t wips_i16_copy(wips_i16_t *dest, const wips_i16_t *src);
wips_status_t wips_u32_copy(wips_u32_t *dest, const wips_u32_t *src);
wips_status_t wips_i32_copy(wips_i32_t *dest, const wips_i32_t *src);
wips_status_t wips_u64_copy(wips_u64_t *dest, const wips_u64_t *src);
wips_status_t wips_i64_copy(wips_i64_t *dest, const wips_i64_t *src);
wips_status_t wips_fp32_copy(wips_fp32_t *dest, const wips_fp32_t *src);
wips_status_t wips_fp64_copy(wips_fp64_t *dest, const wips_fp64_t *src);

void wips_u8_hton(wips_u8_t *data);
void wips_u8_ntoh(wips_u8_t *data);

void wips_i8_hton(wips_i8_t *data);
void wips_i8_ntoh(wips_i8_t *data);

void wips_u16_hton(wips_u16_t *data);
void wips_u16_ntoh(wips_u16_t *data);

void wips_i16_hton(wips_i16_t *data);
void wips_i16_ntoh(wips_i16_t *data);

void wips_u32_hton(wips_u32_t *data);
void wips_u32_ntoh(wips_u32_t *data);

void wips_i32_hton(wips_i32_t *data);
void wips_i32_ntoh(wips_i32_t *data);

void wips_u64_hton(wips_u64_t *data);
void wips_u64_ntoh(wips_u64_t *data);

void wips_i64_hton(wips_i64_t *data);
void wips_i64_ntoh(wips_i64_t *data);

void wips_fp32_hton(wips_fp32_t *data);
void wips_fp32_ntoh(wips_fp32_t *data);

void wips_fp64_hton(wips_fp64_t *data);
void wips_fp64_ntoh(wips_fp64_t *data);

extern wips_vlamethods_t wips_u8_vlamethods;
extern wips_vlamethods_t wips_i8_vlamethods;
extern wips_vlamethods_t wips_u16_vlamethods;
extern wips_vlamethods_t wips_i16_vlamethods;
extern wips_vlamethods_t wips_u32_vlamethods;
extern wips_vlamethods_t wips_i32_vlamethods;
extern wips_vlamethods_t wips_u64_vlamethods;
extern wips_vlamethods_t wips_i64_vlamethods;
extern wips_vlamethods_t wips_fp32_vlamethods;
extern wips_vlamethods_t wips_fp64_vlamethods;

#ifdef __cplusplus
}
#endif