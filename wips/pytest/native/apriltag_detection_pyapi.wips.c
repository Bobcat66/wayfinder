/*
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Copyright (c) 2025 Jesse Kane
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS”
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

// This file was automatically generated by WIPS. Do not attempt to modify manually

#ifdef WIPS_OPTION_BUILD_PYTHON

#ifdef __cplusplus
extern "C" {
#endif

#include "apriltag_detection.wips.h"
#include <string.h>

#define PY_SSIZE_T_CLEAN
#include "apriltag_detection_pyapi.wips.h"

#define WIPS_INTERNAL
#include "wips_detail.h"

// init

static void _wips_apriltag_detection_void_destructor(void *ptr) {
    wips_apriltag_detection_destroy((wips_apriltag_detection_t *)ptr);
}

static PyObject *wips_apriltag_detection_PyObject_new(PyTypeObject* type, PyObject *Py_UNUSED(args), PyObject *Py_UNUSED(kwds)) {
    
    wips_apriltag_detection_PyObject *obj;

    obj = (wips_apriltag_detection_PyObject *)(type->tp_alloc(type,0));
    if (obj) {
        obj->base.wips_type = &wips_apriltag_detection_PyType;
        obj->base.handler = NULL;
        obj->c_obj = NULL;
        return (PyObject *)obj;
    } else {
        PyErr_SetString(PyExc_RuntimeError, "Failed to initialize apriltag_detection");
        return NULL;
    }
}

static int wips_apriltag_detection_PyObject_init(PyObject *self, PyObject *Py_UNUSED(args), PyObject *Py_UNUSED(kwds)) {

    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;

    wips_apriltag_detection_t *c_obj = wips_apriltag_detection_create();
    if (!c_obj) {
        PyErr_NoMemory();
        return -1;
    }
    wips_PyHandler *handler = wips_PyHandler_create((void *)c_obj,_wips_apriltag_detection_void_destructor);
    if (!handler) {
        PyErr_NoMemory();
        return -1;
    }

    obj->c_obj = c_obj;
    obj->base.handler = handler;

    return 0;
}

static void wips_apriltag_detection_PyObject_dealloc(PyObject *self) {

    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;

    if (obj->base.handler) {
        wips_PyHandler_decref(obj->base.handler);
        obj->base.handler = NULL;
        obj->base.wips_type = NULL;
        obj->c_obj = NULL;
    }

    Py_TYPE(self)->tp_free(self);
}

// getsetters
static PyObject *wips_apriltag_detection_PyObject_get_fiducial_id(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_i32_PyType;
    void *c_field = (void *)(&(obj->c_obj->fiducial_id));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_fiducial_id(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_i32_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_i32_t *c_src = (wips_i32_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_i32_t *c_dest = &(obj->c_obj->fiducial_id);
    wips_status_t copy_status = wips_i32_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}
static PyObject *wips_apriltag_detection_PyObject_get_corner0_x(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_fp64_PyType;
    void *c_field = (void *)(&(obj->c_obj->corner0_x));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_corner0_x(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_fp64_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_fp64_t *c_src = (wips_fp64_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_fp64_t *c_dest = &(obj->c_obj->corner0_x);
    wips_status_t copy_status = wips_fp64_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}
static PyObject *wips_apriltag_detection_PyObject_get_corner0_y(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_fp64_PyType;
    void *c_field = (void *)(&(obj->c_obj->corner0_y));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_corner0_y(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_fp64_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_fp64_t *c_src = (wips_fp64_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_fp64_t *c_dest = &(obj->c_obj->corner0_y);
    wips_status_t copy_status = wips_fp64_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}
static PyObject *wips_apriltag_detection_PyObject_get_corner1_x(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_fp64_PyType;
    void *c_field = (void *)(&(obj->c_obj->corner1_x));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_corner1_x(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_fp64_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_fp64_t *c_src = (wips_fp64_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_fp64_t *c_dest = &(obj->c_obj->corner1_x);
    wips_status_t copy_status = wips_fp64_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}
static PyObject *wips_apriltag_detection_PyObject_get_corner1_y(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_fp64_PyType;
    void *c_field = (void *)(&(obj->c_obj->corner1_y));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_corner1_y(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_fp64_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_fp64_t *c_src = (wips_fp64_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_fp64_t *c_dest = &(obj->c_obj->corner1_y);
    wips_status_t copy_status = wips_fp64_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}
static PyObject *wips_apriltag_detection_PyObject_get_corner2_x(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_fp64_PyType;
    void *c_field = (void *)(&(obj->c_obj->corner2_x));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_corner2_x(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_fp64_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_fp64_t *c_src = (wips_fp64_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_fp64_t *c_dest = &(obj->c_obj->corner2_x);
    wips_status_t copy_status = wips_fp64_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}
static PyObject *wips_apriltag_detection_PyObject_get_corner2_y(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_fp64_PyType;
    void *c_field = (void *)(&(obj->c_obj->corner2_y));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_corner2_y(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_fp64_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_fp64_t *c_src = (wips_fp64_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_fp64_t *c_dest = &(obj->c_obj->corner2_y);
    wips_status_t copy_status = wips_fp64_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}
static PyObject *wips_apriltag_detection_PyObject_get_corner3_x(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_fp64_PyType;
    void *c_field = (void *)(&(obj->c_obj->corner3_x));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_corner3_x(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_fp64_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_fp64_t *c_src = (wips_fp64_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_fp64_t *c_dest = &(obj->c_obj->corner3_x);
    wips_status_t copy_status = wips_fp64_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}
static PyObject *wips_apriltag_detection_PyObject_get_corner3_y(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_fp64_PyType;
    void *c_field = (void *)(&(obj->c_obj->corner3_y));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_corner3_y(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_fp64_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_fp64_t *c_src = (wips_fp64_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_fp64_t *c_dest = &(obj->c_obj->corner3_y);
    wips_status_t copy_status = wips_fp64_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}
static PyObject *wips_apriltag_detection_PyObject_get_decision_margin(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_fp64_PyType;
    void *c_field = (void *)(&(obj->c_obj->decision_margin));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_decision_margin(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_fp64_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_fp64_t *c_src = (wips_fp64_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_fp64_t *c_dest = &(obj->c_obj->decision_margin);
    wips_status_t copy_status = wips_fp64_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}
static PyObject *wips_apriltag_detection_PyObject_get_hamming_distance(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_fp64_PyType;
    void *c_field = (void *)(&(obj->c_obj->hamming_distance));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_hamming_distance(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_fp64_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_fp64_t *c_src = (wips_fp64_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_fp64_t *c_dest = &(obj->c_obj->hamming_distance);
    wips_status_t copy_status = wips_fp64_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}
static PyObject *wips_apriltag_detection_PyObject_get_tag_family_id(PyObject *self, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_PyType *fieldtype = &wips_u8_PyType;
    void *c_field = (void *)(&(obj->c_obj->tag_family_id));
    PyObject *py_field = fieldtype->wrapper(c_field,obj->base.handler);
    if (!py_field) {
        // Failed to wrap value, propagate error
        return NULL;
    }
    return py_field;
}
static int wips_apriltag_detection_PyObject_set_tag_family_id(PyObject *self, PyObject *value, void *Py_UNUSED(closure)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return -1;
    }

    // value is not None
    // verify value is of the correct type
    wips_PyType *valtype = &wips_u8_PyType;
    if (Py_TYPE(value) != valtype->python_type) {
        PyErr_SetString(PyExc_TypeError,"Argument type does not match field type");
        return -1;
    }
    // assign value
    wips_u8_t *c_src = (wips_u8_t *)(valtype->unwrapper(value));
    if (!c_src) {
        // Failed to unwrap value, propagate error
        return -1;
    }
    wips_u8_t *c_dest = &(obj->c_obj->tag_family_id);
    wips_status_t copy_status = wips_u8_copy(
        c_dest,
        c_src
    );
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to copy value");
        return -1;
    }
    return 0;
}

static PyGetSetDef wips_apriltag_detection_PyObject_getsetters[] = {
    {
        "fiducial_id",
        (getter)wips_apriltag_detection_PyObject_get_fiducial_id,
        (setter)wips_apriltag_detection_PyObject_set_fiducial_id,
        "i32",
        NULL
    },
    {
        "corner0_x",
        (getter)wips_apriltag_detection_PyObject_get_corner0_x,
        (setter)wips_apriltag_detection_PyObject_set_corner0_x,
        "fp64",
        NULL
    },
    {
        "corner0_y",
        (getter)wips_apriltag_detection_PyObject_get_corner0_y,
        (setter)wips_apriltag_detection_PyObject_set_corner0_y,
        "fp64",
        NULL
    },
    {
        "corner1_x",
        (getter)wips_apriltag_detection_PyObject_get_corner1_x,
        (setter)wips_apriltag_detection_PyObject_set_corner1_x,
        "fp64",
        NULL
    },
    {
        "corner1_y",
        (getter)wips_apriltag_detection_PyObject_get_corner1_y,
        (setter)wips_apriltag_detection_PyObject_set_corner1_y,
        "fp64",
        NULL
    },
    {
        "corner2_x",
        (getter)wips_apriltag_detection_PyObject_get_corner2_x,
        (setter)wips_apriltag_detection_PyObject_set_corner2_x,
        "fp64",
        NULL
    },
    {
        "corner2_y",
        (getter)wips_apriltag_detection_PyObject_get_corner2_y,
        (setter)wips_apriltag_detection_PyObject_set_corner2_y,
        "fp64",
        NULL
    },
    {
        "corner3_x",
        (getter)wips_apriltag_detection_PyObject_get_corner3_x,
        (setter)wips_apriltag_detection_PyObject_set_corner3_x,
        "fp64",
        NULL
    },
    {
        "corner3_y",
        (getter)wips_apriltag_detection_PyObject_get_corner3_y,
        (setter)wips_apriltag_detection_PyObject_set_corner3_y,
        "fp64",
        NULL
    },
    {
        "decision_margin",
        (getter)wips_apriltag_detection_PyObject_get_decision_margin,
        (setter)wips_apriltag_detection_PyObject_set_decision_margin,
        "fp64",
        NULL
    },
    {
        "hamming_distance",
        (getter)wips_apriltag_detection_PyObject_get_hamming_distance,
        (setter)wips_apriltag_detection_PyObject_set_hamming_distance,
        "fp64",
        NULL
    },
    {
        "tag_family_id",
        (getter)wips_apriltag_detection_PyObject_get_tag_family_id,
        (setter)wips_apriltag_detection_PyObject_set_tag_family_id,
        "u8",
        NULL
    },
    {NULL}
};

// wips_PyType

static void *wips_apriltag_detection_void_create() {
    return (void *)wips_apriltag_detection_create();
}

static PyObject *wips_apriltag_detection_wrap(void *c_obj, wips_PyHandler *handler) {
    wips_apriltag_detection_PyObject *obj = 
        (wips_apriltag_detection_PyObject *)wips_apriltag_detection_PyObject_new(
            &wips_apriltag_detection_PyTypeObject, NULL, NULL
        );
    
    // Failed to initialize object, propagate error
    if (!obj) return NULL;

    obj->base.handler = handler;
    obj->c_obj = (wips_apriltag_detection_t *)c_obj;
    wips_PyHandler_incref(handler);

    return (PyObject *)obj;
}

static void *wips_apriltag_detection_unwrap(PyObject *py_obj) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)(py_obj);
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    return (void *)(obj->c_obj);
}

static wips_status_t wips_apriltag_detection_void_copier(void *dest, const void *src) {
    return wips_apriltag_detection_copy(
        (wips_apriltag_detection_t *)dest,
        (const wips_apriltag_detection_t *)src
    );
}

static PyObject *wips_apriltag_detection_extractor(void *obj) {
    PyObject *dict = PyDict_New();
    // Failed to create dict, propagate error
    if (!dict) return NULL;

    wips_apriltag_detection_t *c_obj = (wips_apriltag_detection_t *)obj;
    {
        wips_PyType *valtype = &wips_i32_PyType;
        void *c_value = (void *)(&(c_obj->fiducial_id));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "fiducial_id", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }
    {
        wips_PyType *valtype = &wips_fp64_PyType;
        void *c_value = (void *)(&(c_obj->corner0_x));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "corner0_x", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }
    {
        wips_PyType *valtype = &wips_fp64_PyType;
        void *c_value = (void *)(&(c_obj->corner0_y));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "corner0_y", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }
    {
        wips_PyType *valtype = &wips_fp64_PyType;
        void *c_value = (void *)(&(c_obj->corner1_x));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "corner1_x", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }
    {
        wips_PyType *valtype = &wips_fp64_PyType;
        void *c_value = (void *)(&(c_obj->corner1_y));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "corner1_y", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }
    {
        wips_PyType *valtype = &wips_fp64_PyType;
        void *c_value = (void *)(&(c_obj->corner2_x));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "corner2_x", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }
    {
        wips_PyType *valtype = &wips_fp64_PyType;
        void *c_value = (void *)(&(c_obj->corner2_y));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "corner2_y", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }
    {
        wips_PyType *valtype = &wips_fp64_PyType;
        void *c_value = (void *)(&(c_obj->corner3_x));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "corner3_x", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }
    {
        wips_PyType *valtype = &wips_fp64_PyType;
        void *c_value = (void *)(&(c_obj->corner3_y));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "corner3_y", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }
    {
        wips_PyType *valtype = &wips_fp64_PyType;
        void *c_value = (void *)(&(c_obj->decision_margin));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "decision_margin", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }
    {
        wips_PyType *valtype = &wips_fp64_PyType;
        void *c_value = (void *)(&(c_obj->hamming_distance));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "hamming_distance", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }
    {
        wips_PyType *valtype = &wips_u8_PyType;
        void *c_value = (void *)(&(c_obj->tag_family_id));
        PyObject *value = valtype->extractor(c_value);
        if (!value) {
            // failed to extract, give up
            Py_DECREF(dict);
            return NULL;
        }
        if (PyDict_SetItemString(dict, "tag_family_id", value) != 0) {
            // Failed to assign value, give up and propagate error
            Py_DECREF(dict);
            Py_DECREF(value);
            return NULL;
        }
        // Prevent memory leaks, dict assignment does not steal reference
        Py_DECREF(value);
    }

    return dict;
}

wips_PyType wips_apriltag_detection_PyType = {
    .type_id = WIPS_struct,
    .size = GET_SIZE(apriltag_detection),
    .python_type = &wips_apriltag_detection_PyTypeObject,
    .vlamethods = &wips_apriltag_detection_vlamethods,
    .creator = wips_apriltag_detection_void_create,
    .wrapper = wips_apriltag_detection_wrap,
    .unwrapper = wips_apriltag_detection_unwrap,
    .destructor = _wips_apriltag_detection_void_destructor,
    .copier = wips_apriltag_detection_void_copier,
    .extractor = wips_apriltag_detection_extractor
};

// Methods

static PyObject *wips_apriltag_detection_PyObject_copy(PyObject *self, PyObject *Py_UNUSED(args)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    wips_apriltag_detection_t *copy = wips_apriltag_detection_create();
    if (!copy) {
        PyErr_NoMemory();
        return NULL;
    }

    wips_status_t copy_status = wips_apriltag_detection_copy(copy,obj->c_obj);
    if (copy_status != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to copy object");
        wips_apriltag_detection_destroy(copy);
        return NULL;
    }

    wips_PyHandler *handler = wips_PyHandler_create((void *)copy,_wips_apriltag_detection_void_destructor);

    if (!handler) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to create handler");
        wips_apriltag_detection_destroy(copy);
        return NULL;
    }

    PyObject *pyobj = wips_apriltag_detection_wrap((void *)copy,handler);

    if (!pyobj) {
        wips_PyHandler_decref(handler); // destroys handler and resource
        return NULL;
    }

    return pyobj;
}

static PyObject *wips_apriltag_detection_PyObject_encode(PyObject *Py_UNUSED(self), PyObject *args) {
    PyObject *py_struct;

    if (!PyArg_ParseTuple(args, "O", &py_struct)) {
        return NULL;
    }

    if (Py_TYPE(py_struct) != &wips_apriltag_detection_PyTypeObject) {
        PyErr_SetString(PyExc_TypeError, "input struct must be of type apriltag_detection");
        return NULL;
    }

    wips_apriltag_detection_t *c_obj = (wips_apriltag_detection_t *)((&wips_apriltag_detection_PyType)->unwrapper(py_struct));
    if (!c_obj) return NULL;

    wips_blob_t *blob = wips_blob_create(GET_SIZE(apriltag_detection));

    wips_result_t encode_status = wips_encode_apriltag_detection(blob, c_obj);
    if (encode_status.status_code != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to encode apriltag_detection");
        wips_blob_destroy(blob);
        return NULL;
    }

    PyObject *pyblob = (PyObject *)wips_blob_PyObject_create(blob);
    if (!pyblob) {
        wips_blob_destroy(blob);
        return NULL;
    }

    return pyblob;
}

static PyObject *wips_apriltag_detection_PyObject_decode(PyObject *Py_UNUSED(self), PyObject *args) {
    PyObject *pyblob;

    if (!PyArg_ParseTuple(args, "O", &pyblob)) {
        return NULL;
    }

    if (Py_TYPE(pyblob) != &wips_blob_PyTypeObject) {
        PyErr_SetString(PyExc_TypeError, "input struct must be a wips blob");
        return NULL;
    }

    wips_apriltag_detection_t *c_obj = wips_apriltag_detection_create();
    wips_blob_t *c_blob = ((wips_blob_PyObject *)(pyblob))->c_obj;

    if (!c_blob) {
        PyErr_SetString(PyExc_RuntimeError, "Blob is NULL");
        wips_apriltag_detection_destroy(c_obj);
        return NULL;
    }

    wips_result_t decode_status = wips_decode_apriltag_detection(c_obj,c_blob);

    if (decode_status.status_code != WIPS_STATUS_OK) {
        PyErr_SetString(PyExc_RuntimeError, "Failed to decode apriltag_detection");
        wips_apriltag_detection_destroy(c_obj);
        return NULL;
    }

    wips_PyHandler *handler = wips_PyHandler_create((void *)c_obj, _wips_apriltag_detection_void_destructor);
    if (!handler) {
        PyErr_SetString(PyExc_RuntimeError,"Failed to create handler");
        wips_apriltag_detection_destroy(c_obj);
        return NULL;
    }

    PyObject *pyobj = wips_apriltag_detection_wrap((void *)c_obj, handler);
    if (!pyobj) {
        wips_PyHandler_decref(handler); // destroys handler and resource
        return NULL;
    }
    
    return pyobj;
}

static PyObject *wips_apriltag_detection_PyObject_extract(PyObject *self, PyObject *Py_UNUSED(args)) {
    wips_apriltag_detection_PyObject *obj = (wips_apriltag_detection_PyObject *)self;
    if (!obj->c_obj) {
        PyErr_SetString(PyExc_AttributeError,"Struct is not initialized");
        return NULL;
    }

    return (&wips_apriltag_detection_PyType)->extractor((void *)(obj->c_obj));
}

static PyMethodDef wips_apriltag_detection_PyObject_methods[] = {
    {
        "encode",
        wips_apriltag_detection_PyObject_encode,
        METH_VARARGS | METH_STATIC,
        "Encodes a struct"
    },
    {
        "decode",
        wips_apriltag_detection_PyObject_decode,
        METH_VARARGS | METH_STATIC,
        "Decodes a blob"
    },
    {
        "copy",
        wips_apriltag_detection_PyObject_copy,
        METH_NOARGS,
        "Creates a deep copy"
    },
    {
        "extract",
        wips_apriltag_detection_PyObject_extract,
        METH_NOARGS,
        "Extracts struct to a python dict"
    },
    {NULL, NULL, 0, NULL}
};

PyTypeObject wips_apriltag_detection_PyTypeObject = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "wips.apriltag_detection",
    .tp_basicsize = sizeof(wips_apriltag_detection_PyObject),
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_base = &wips_struct_PyTypeObject,
    .tp_new = wips_apriltag_detection_PyObject_new,
    .tp_init = wips_apriltag_detection_PyObject_init,
    .tp_dealloc = wips_apriltag_detection_PyObject_dealloc,
    .tp_methods = wips_apriltag_detection_PyObject_methods,
    .tp_getset = wips_apriltag_detection_PyObject_getsetters
};

#ifdef __cplusplus
}
#endif

#endif // WIPS_OPTION_BUILD_PYTHON